/**
 * @remix-run/dev v1.3.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var stream = require('stream');
var util = require('util');
var path = require('path');
var fse = require('fs-extra');
var fetch = require('node-fetch');
var gunzip = require('gunzip-maybe');
var tar = require('tar-fs');
var semver = require('semver');
var url = require('url');
var child_process = require('child_process');
var sortPackageJSON = require('sort-package-json');
var packageJson = require('./package.json');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var stream__default = /*#__PURE__*/_interopDefaultLegacy(stream);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var fse__default = /*#__PURE__*/_interopDefaultLegacy(fse);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);
var gunzip__default = /*#__PURE__*/_interopDefaultLegacy(gunzip);
var tar__default = /*#__PURE__*/_interopDefaultLegacy(tar);
var semver__namespace = /*#__PURE__*/_interopNamespace(semver);
var sortPackageJSON__default = /*#__PURE__*/_interopDefaultLegacy(sortPackageJSON);
var packageJson__default = /*#__PURE__*/_interopDefaultLegacy(packageJson);

const remixDevPackageVersion = packageJson__default["default"].version;
async function createApp({
  appTemplate,
  projectDir,
  remixVersion = remixDevPackageVersion,
  installDeps,
  useTypeScript,
  githubToken = process.env.GITHUB_TOKEN
}) {
  // Check the node version
  let versions = process.versions;

  if (versions !== null && versions !== void 0 && versions.node && semver__namespace.major(versions.node) < 14) {
    throw new Error(`ï¸ðŸš¨ Oops, Node v${versions.node} detected. Remix requires a Node version greater than 14.`);
  } // Create the app directory


  let relativeProjectDir = path__default["default"].relative(process.cwd(), projectDir);
  let projectDirIsCurrentDir = relativeProjectDir === "";

  if (!projectDirIsCurrentDir) {
    if (fse__default["default"].existsSync(projectDir)) {
      throw new Error(`ï¸ðŸš¨ Oops, "${relativeProjectDir}" already exists. Please try again with a different directory.`);
    }
  }
  /**
   * Grab the template
   * First we'll need to determine if the template we got is
   * - file on disk
   * - directory on disk
   * - tarball URL (github or otherwise)
   * - github owner/repo
   * - example in remix-run org
   * - template in remix-run org
   */


  let templateType = await detectTemplateType(appTemplate, useTypeScript, githubToken);
  let options = {
    useTypeScript,
    token: githubToken
  };

  switch (templateType) {
    case "local":
      {
        let filepath = appTemplate.startsWith("file://") ? url.fileURLToPath(appTemplate) : appTemplate;

        if (!fse__default["default"].existsSync(filepath)) {
          throw new Error(`ï¸ðŸš¨ Oops, "${filepath}" does not exist.`);
        }

        if (fse__default["default"].statSync(filepath).isDirectory()) {
          await fse__default["default"].copy(filepath, projectDir);
          break;
        }

        if (appTemplate.endsWith(".tar.gz")) {
          await extractLocalTarball(projectDir, filepath);
          break;
        }
      }

    case "remoteTarball":
      {
        await downloadAndExtractTarball(projectDir, appTemplate, options);
        break;
      }

    case "example":
      {
        await downloadAndExtractTemplateOrExample(projectDir, appTemplate, "examples", options);
        break;
      }

    case "template":
      {
        await downloadAndExtractTemplateOrExample(projectDir, appTemplate, "templates", options);
        break;
      }

    case "repo":
      {
        let {
          filePath,
          tarballURL
        } = await getTarballUrl(appTemplate, githubToken);
        await downloadAndExtractTarball(projectDir, tarballURL, { ...options,
          filePath
        });
        break;
      }

    default:
      throw new Error(`Unable to determine template type for "${appTemplate}"`);
  } // Update remix deps


  let appPkg = require(path__default["default"].join(projectDir, "package.json"));

  ["dependencies", "devDependencies"].forEach(pkgKey => {
    for (let key in appPkg[pkgKey]) {
      if (appPkg[pkgKey][key] === "*") {
        appPkg[pkgKey][key] = semver__namespace.prerelease(remixVersion) ? // Templates created from prereleases should pin to a specific version
        remixVersion : "^" + remixVersion;
      }
    }
  });
  appPkg = sortPackageJSON__default["default"](appPkg);
  await fse__default["default"].writeJSON(path__default["default"].join(projectDir, "package.json"), appPkg, {
    spaces: 2,
    replacer: null
  });

  if (installDeps) {
    // TODO: use yarn/pnpm/npm
    let npmConfig = child_process.execSync("npm config get @remix-run:registry", {
      encoding: "utf8"
    });

    if (npmConfig !== null && npmConfig !== void 0 && npmConfig.startsWith("https://npm.remix.run")) {
      console.log("ðŸš¨ Oops! You still have the private Remix registry configured. Please run `npm config delete @remix-run:registry` or edit your .npmrc file to remove it.");
      process.exit(1);
    }

    child_process.execSync("npm install", {
      stdio: "inherit",
      cwd: projectDir
    });
  }
} // this is natively a promise in node 15+ stream/promises

const pipeline = util.promisify(stream__default["default"].pipeline);

async function extractLocalTarball(projectDir, filePath) {
  await pipeline(fse__default["default"].createReadStream(filePath), gunzip__default["default"](), tar__default["default"].extract(projectDir, {
    strip: 1
  }));
}

async function downloadAndExtractTemplateOrExample(projectDir, name, type, options) {
  let response = await fetch__default["default"]("https://codeload.github.com/remix-run/remix/tar.gz/main", options.token ? {
    headers: {
      Authorization: `token ${options.token}`
    }
  } : {});

  if (response.status !== 200) {
    throw new Error(`Error fetching repo: ${response.status}`);
  }

  let cwd = path__default["default"].dirname(projectDir);
  let desiredDir = path__default["default"].basename(projectDir);
  let exampleOrTemplateName = type === "templates" && options.useTypeScript ? `${name}-ts` : name;
  let templateDir = path__default["default"].join(desiredDir, type, exampleOrTemplateName);
  await pipeline(response.body.pipe(gunzip__default["default"]()), tar__default["default"].extract(cwd, {
    map(header) {
      let originalDirName = header.name.split("/")[0];
      header.name = header.name.replace(originalDirName, desiredDir); // https://github.com/remix-run/remix/issues/2356#issuecomment-1071458832

      if (path__default["default"].sep === "\\") {
        templateDir = templateDir.replace("\\", "/");
      }

      if (!header.name.startsWith(templateDir + "/")) {
        header.name = "__IGNORE__";
      } else {
        header.name = header.name.replace(templateDir, desiredDir);
      }

      return header;
    },

    ignore(_filename, header) {
      if (!header) {
        throw new Error(`Header is undefined`);
      }

      return header.name === "__IGNORE__";
    }

  }));
}

async function downloadAndExtractTarball(projectDir, url, options) {
  let desiredDir = path__default["default"].basename(projectDir);
  let response = await fetch__default["default"](url, options.token ? {
    headers: {
      Authorization: `token ${options.token}`
    }
  } : {});

  if (response.status !== 200) {
    throw new Error(`Error fetching repo: ${response.status}`);
  }

  await pipeline(response.body.pipe(gunzip__default["default"]()), tar__default["default"].extract(projectDir, {
    map(header) {
      let originalDirName = header.name.split("/")[0];
      header.name = header.name.replace(originalDirName, desiredDir);
      let templateFiles = options.filePath ? path__default["default"].join(desiredDir, options.filePath) + path__default["default"].sep : desiredDir + path__default["default"].sep; // https://github.com/remix-run/remix/issues/2356#issuecomment-1071458832

      if (path__default["default"].sep === "\\") {
        templateFiles = templateFiles.replace("\\", "/");
      }

      if (!header.name.startsWith(templateFiles)) {
        header.name = "__IGNORE__";
      } else {
        header.name = header.name.replace(templateFiles, "");
      }

      return header;
    },

    ignore(_filename, header) {
      if (!header) {
        throw new Error(`Header is undefined`);
      }

      return header.name === "__IGNORE__";
    }

  }));
}

async function getTarballUrl(from, token) {
  let info = await getRepoInfo(from, token);

  if (!info) {
    throw new Error(`Could not find repo: ${from}`);
  }

  return {
    tarballURL: `https://codeload.github.com/${info.owner}/${info.name}/tar.gz/${info.branch}`,
    filePath: info.filePath
  };
}

async function getRepoInfo(from, token) {
  try {
    let url = new URL(from);

    if (url.hostname !== "github.com") {
      return;
    }

    let [, owner, name, t, branch, ...file] = url.pathname.split("/");
    let filePath = file.join(path__default["default"].sep);

    if (t === undefined) {
      let defaultBranch = await getDefaultBranch(`${owner}/${name}`, token);
      return {
        owner,
        name,
        branch: defaultBranch,
        filePath
      };
    }

    if (owner && name && branch && t === "tree") {
      return {
        owner,
        name,
        branch,
        filePath
      };
    }

    return;
  } catch (error) {
    // invalid url, but it could be a github shorthand for
    // :owner/:repo
    try {
      let parts = from.split("/");

      if (parts.length === 1) {
        parts.unshift("remix-run");
      }

      let [owner, name] = parts;
      let branch = await getDefaultBranch(`${owner}/${name}`, token);
      return {
        owner,
        name,
        branch,
        filePath: ""
      };
    } catch (error) {
      // invalid url, but we can try to match a template or example
      return undefined;
    }
  }
}

async function getDefaultBranch(repo, token) {
  let response = await fetch__default["default"](`https://api.github.com/repos/${repo}`, {
    headers: {
      Authorization: token ? `token ${token}` : "",
      Accept: "application/vnd.github.v3+json"
    }
  });

  if (response.status !== 200) {
    throw new Error(`Error fetching repo: ${response.status} ${response.statusText}`);
  }

  let info = await response.json();
  return info.default_branch;
}

async function isRemixTemplate(name, useTypeScript, token) {
  let promise = await fetch__default["default"](`https://api.github.com/repos/remix-run/remix/contents/templates`, {
    headers: {
      Accept: "application/vnd.github.v3+json",
      Authorization: token ? `token ${token}` : ""
    }
  });

  if (!promise.ok) {
    throw new Error(`Error fetching repo: ${promise.status} ${promise.statusText}`);
  }

  let results = await promise.json();
  let possibleTemplateName = useTypeScript ? `${name}-ts` : name;
  let template = results.find(result => {
    return result.name === possibleTemplateName;
  });
  if (!template) return undefined;
  return template.name;
}

async function isRemixExample(name, token) {
  let promise = await fetch__default["default"](`https://api.github.com/repos/remix-run/remix/contents/examples`, {
    headers: {
      Accept: "application/vnd.github.v3+json",
      Authorization: token ? `token ${token}` : ""
    }
  });

  if (!promise.ok) {
    throw new Error(`Error fetching repo: ${promise.status} ${promise.statusText}`);
  }

  let results = await promise.json();
  let example = results.find(result => result.name === name);
  if (!example) return undefined;
  return example.name;
}

async function detectTemplateType(template, useTypeScript, token) {
  if (template.startsWith("file://") || fse__default["default"].existsSync(template)) {
    return "local";
  }

  if (await isRemixTemplate(template, useTypeScript, token)) {
    return "template";
  }

  if (await isRemixExample(template, token)) {
    return "example";
  }

  if (await getRepoInfo(template, token)) {
    return "repo";
  }

  return "remoteTarball";
}

exports.createApp = createApp;
